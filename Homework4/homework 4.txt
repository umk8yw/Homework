-----------------------------------------------------------------------------------------------------
	Detecting types
-----------------------------------------------------------------------------------------------------

	Questions

1.	What is the difference between upcasting and downcasting? 
2.	What is the difference between “traditional” RTTI and reflection? 
3.	Let there be the following code fragment: 
public class Circle {}
public class Shape extends Circle {}
public class Test {
  public static void main(String[] args) {	  
    Circle c = new Circle();
  }
}
Pretend you are an implementation of the Java Virtual Machine and try to evaluate (to a boolean value) the following expressions:
a.	c.isInstance(Circle)
b.	c instanceof Shape
c.	c.getClass() == Shape.class
d.	c.isInstance(Shape)
e.	c.getClass() == Circle.class

4.	Is it possible to build a valid line of Java code in a string and then execute it at run-time (Like in the sample below)? Write a short program to back-up your answer.  
String line = "someClass.method()"; 
run(line);   

	Problems:

1.	Write a very simple graphical editor that allows you to draw objects deriving from the Shape class. Read the available classes of shapes from a configuration file, and present to the user a simple menu that allows him to select the shape to be drawn. 
public interface Shape {
  String draw();
  String getName();
}
Note: Write the simplest thing that meets the requirements. The dimensions of the shapes will be hardcoded (for ex.: every Circle drawn will have the same radius)

2.	Write a program that by means of reflection creates an instance of the following class: 
public class Unknown {
  private int hidden;
  public Unknown(int i) {
    this.hidden = i + 1;
  }
}
3.	Write a test program using reflection to print out the value of the hidden attribute after an instance of the Unknown class has been created in the previous exercise. If you have succeeded, try to double the value of the hidden attribute of this instance. Hint: check-out the java.lang.reflect package.

-----------------------------------------------------------------------------------------------------
	Passing and returning objects
-----------------------------------------------------------------------------------------------------

	Questions

1.	What is aliasing? Are there possible problems with aliasing? 
2.	How do you send a message to an object? 
3.	What “pass by value” means? Explain how passing arguments works in Java. 
4.	What is the difference between shallow copy and deep copy?
5.	What is wrong in the following code? 

class MyObject implements Cloneable {
int i; 
MyObject(int ii) { i = ii; } 
public Object clone() { 
  Object o = super.clone(); 
  return o;
}
public String toString() { 
  return Integer.toString(i);
} 
}

6.	How many methods has the Cloneable interface? What are the reasons of this interface existence? -
7.	Is C++ special keyword const available in Java? 
8.	What is the difference between a read-only object and an immutable object? What is an immutable object? Give an example of a read-only class. 
9.	What will be the results of the following code? 
public class StringUtil {
  public static String lowcase(String s) {
    return s.toLowerCase();
  }
  public static void main(String[] args) {
    String q = "world is not ENOUGH";
    String qq = lowcase(q);
    String qqq = q.substring(q.indexOf("ENOUGH"));
    qqq.concat(" is not enough");
    System.out.println(q);
    System.out.println(qq);
    System.out.println(qqq);
  }
}

	Problems

1.	Implement the following classes and add deep cloneability to all classes via cloning.
Class Point
attributes: int x, int y
methods: setters, getters, draw, clone
Class Line 
attributes: Point point1, Point point2
 methods: setters, getters, draw, clone
Class Circle
attributes:  Point center, int radius
methods: setters, getters, draw, area, clone
Class Shape
attributes: Circle circle, Line line
 methods: draw, clone

2.	Implement arithmetical operations on complex numbers having the form a+i*b using the mutable-companion class technique. Implement a method that adds the result of the expression (2+3*i)*(4+5*i)*(6+7*i) to the object owner of the method.
